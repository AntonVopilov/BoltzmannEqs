#!/usr/bin/env python3

"""

.. module:: printerTools
    :synopsis: This module provides functions for printing and reading the solutions. 


:author: Andre Lessa <lessa.a.p@gmail.com>

"""

import os,sys
import numpy as np
import logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)
import warnings
warnings.filterwarnings('error')

def printSummary(solution,outFile=None):
    """
    Prints basic summary of solutions.
    """
    #Solution summary:
    if outFile:
        if hasattr(outFile,'write'):
            f = outFile    
        else:    
            f = open(outFile,'a')
    else:
        f = sys.stdout
        
    T = solution.T
    TF = T[-1]
    f.write('#-------------\n')
    f.write('# Summary\n')
    f.write('# TF=%1.2g\n' %TF)
    for comp in solution.components:
        if comp.Tdecay:
            Tlast = max(comp.Tdecay,TF)
        else:
            Tlast = TF
        #Get point closest to Tlast    
        i = (np.abs(T - Tlast)).argmin()                    
        rhoF = comp.rho[i]
        nF = comp.n[i]
        Tfinal = T[i]
        omega = comp.getOmega(rhoF,nF,Tfinal)        
        if not comp.Tdecay:
            tag = '(@TF)'
        else:
            tag = '(@decay)'
        f.write('# %s: T(decouple)~= %s | T(decay)~= %s | Omega h^2 %s = %1.4g\n' %(comp.label,
                                                                                      comp.Tdecouple,comp.Tdecay,tag,omega))
        f.write('# \n')
    
    DNeff = 0.
    for comp in solution.components:
        rho = comp.rho[-1]
        n = comp.n[-1]
        DNeff += comp.getDNeff(rho, n, TF)
                
    f.write('# Delta Neff (T = %1.2g) = %1.2g \n' %(TF,DNeff))
    f.write('#-------------\n')
    f.close()

def printData(solution,outFile=None):
    """
    Prints the evolution of number and energy densities of the species to the outputFile 
    """
    
    if outFile:
        if hasattr(outFile,'write'):
            f = outFile    
        else:    
            f = open(outFile,'a')
        header = ['x','T','R','S']
        values = [getattr(solution,label) for label in header]
        for comp in solution.components:
            header += ['n_%s' %comp.label,'rho_%s' %comp.label]
            values.append(comp.n)
            values.append(comp.rho)

        maxLength = max([len(s) for s in header])
        header = ' '.join(str(x).center(maxLength) for x in header)
        if any(len(v) != len(values[0]) for v in values):
            logger.error("Data has distinct lengths and can not be written to file.")
            f.close()
            return False
        data = np.column_stack(values)
        f.write('#--------------\n')
        np.savetxt(f,data,delimiter=' ',header = header,fmt=('{:^%i}'%(maxLength-5)).format('%1.4E'))
        f.write('#--------------\n')    
        f.close()

        
def printParameters(parameters,outFile=None):
    """
    Prints input parameters.
    
    :param parameters: dictionary with parameters labels and their values
    """        
    if outFile:
        f = open(outFile,'a')
        f.write('#-------------\n')
        f.write('# Parameters:\n')
        for par,val in sorted(parameters):
            f.write('# %s = %s\n' %(par,val))
        f.write('#-------------\n')            
  
def getDataFrom(dataFile):    
    """
    Reads a datafile generated by printData, printSummary and printParameters
    and returns a dictionary with the information.
    """
    
    if not os.path.isfile(dataFile):
        logger.error('File %s not found' %dataFile)
        return None,None,None
    
    f = open(dataFile,'r')
    data = f.read()
    
    #Get parameters
    parDict = {}
    if 'Parameters' in data:
        ipar = data.find('Parameters')
        parameters = data[ipar:data.find('---',ipar)].split('\n')        
        for par in parameters:
            if not '=' in par: continue
            parameter,val = par.split('=')
            val = val.replace('\n','')
            try:
                val = eval(val)
            except: pass
            parameter = parameter.replace('#','').strip()
            parDict[parameter] = val
            
    #Get Summary
    summaryDict = {}
    if 'Summary' in data:
        ipar = data.find('Summary')
        summaryData = data[ipar:data.find('---',ipar)].split('\n')        
        for par in summaryData:
            par = par.replace('#','').strip()
            if not '=' in par: continue
            if par.count('=') == 1:
                par = par.split('=')
                summaryDict[par[0].strip()] = eval(par[1])
            elif '|' in par and ':' in par:
                compLabel = par.split(':')[0]
                summaryDict[compLabel] = {}
                vals = par.split(':')[1].split('|')
                for v in vals:
                    label,val = v.split('=')
                    label = label.strip()
                    try:
                        val = eval(val)
                    except:
                        val = val.strip()
                    summaryDict[compLabel][label] = val            

    #Get data
    dataDict = {}
    if 'Header' in data:
        ipar = data.find('Header')
        dataPts = data[ipar:data.find('---',ipar)]
        header = dataPts.split('\n')[1]
        header = header.split('  ')
        header = [h.strip() for h in header if h.replace('#','').strip()]
        dataDict = dict([[h,[]] for h in header])
    
        #Get data points    
        pts = dataPts.split('\n')[2:]
    
        for pt in pts:
            pt = pt.replace('#','')
            if not pt.strip():
                continue
            pt = pt.split(' ')
            pt = [eval(x) for x in pt if x.strip()]
            for i,val in enumerate(pt):
                dataDict[header[i]].append(val)

    return parDict,summaryDict,dataDict
