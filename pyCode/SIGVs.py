#!/usr/bin/env python

"""

.. module:: SIGVs
    :synopsis: This module defines all the annihilation cross-sections*v for the components at temperature T

:synopsis: This module defines all the annihilation cross-sections*v for the components at temperature T
:author: Andre Lessa <lessa.a.p@gmail.com>

"""


IDs = ['axino', 'saxion', 'saxionCO', 'axion', 'axionCO', 'gravitino', 'neutralino']

from scipy.special import kn
import modelParameters
from AuxFuncs import getParsAt
from parameters import Pi, MP, Zeta3, LQCD
from math import log, exp
import Mass
import logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


def axino(T):
    """Axino sigma.v as a function of temperature """
    
    pars = getParsAt(T)
    mu = pars['mu']
    gSU2 = pars['gSU2']
    
    cH = modelParameters.cH
    vPQ = modelParameters.vPQ
    
    xm = max(mu,Mass.axino(T))/T   #The cross-section gets suppressed either bcs T << axino mass or T << Higgsino mass      
    BesselInt = kn(2,xm)*xm**2    
    sigv = 100.*gSU2**2*cH**2*(3./2.)*mu**2*BesselInt/(32.*Pi*vPQ**2*Zeta3**2*T**2)
    
    return sigv

def saxion(T):
    """Saxion sigma.v as a function of temperature """
    
    pars = getParsAt(T)
    mu = pars['mu']
    gSU2 = pars['gSU2']
    gSU3 = pars['gSU3']
    
    modelType = modelParameters.modelType
    cH = modelParameters.cH
    vPQ = modelParameters.vPQ
    
    if modelType == 'DFSZ':
        xm = max(mu,Mass.saxion(T))/T      #The cross-section gets suppressed either bcs T << saxion mass or T << Higgsino mass
        if xm > 10.**(-4): BesselInt = kn(2,xm)*xm**2
        else: BesselInt = 2. - xm**2/2.
        sigv = 100.*gSU2**2*cH**2*(3./2.)*mu**2*BesselInt/(32.*Pi*vPQ**2*Zeta3**2*T**2)
    else:
        sigv = (9./(128.*Zeta3*Pi**3))*gSU3**6*log(1.0126/gSU3)/fa**2
        
    return sigv

def saxionCO(T):
    """Saxion sigma.v as a function of temperature """
   
    return 0.

def axion(T):
    """Axion sigma.v as a function of temperature """
    
    pars = getParsAt(T)
    mu = pars['mu']
    gSU2 = pars['gSU2']
    gSU3 = pars['gSU3']
    
    modelType = modelParameters.modelType
    cH = modelParameters.cH
    vPQ = modelParameters.vPQ
    
    if modelType == 'DFSZ':
        xm = max(mu,Mass.axion(T))/T      #The cross-section gets suppressed either bcs T << axion mass or T << Higgsino mass
        if xm > 10.**(-4): BesselInt = kn(2,xm)*xm**2
        else: BesselInt = 2. - xm**2/2.
        sigv = 100.*gSU2**2*cH**2*(3./2.)*mu**2*BesselInt/(32.*Pi*vPQ**2*Zeta3**2*T**2)
    else:
        sigv = (9./(128.*Zeta3*Pi**3))*gSU3**6*log(1.0126/gSU3)/fa**2
        
    return sigv
 
def axionCO(T):
    """Axion sigma.v as a function of temperature """
    
    return 0.

def gravitino(T):
    """Gravitino sigma.v as a function of temperature """
    
    pars = getParsAt(T)
    gSU3 = pars["gSU3"]
    gSU2 = pars["gSU2"]
    gPr = pars["gPr"]
    M1 = pars["M1"]
    M2 = pars["M2"]
    M3 = pars["M3"]
    
    sigv = (1.37/MP**2)*(
    72*log(1.271/gSU3)*gSU3**2*(1+M3**2/(3*Mass.gravitino(T)**2)) +
    27*log(1.312/gSU2)*gSU2**2*(1+M2**2/(3*Mass.gravitino(T)**2)) +
    11*log(1.266/gPr)*gPr**2*(1+M1**2/(3*Mass.gravitino(T)**2)))
    
    return sigv

def neutralino(T):
    """Neutralino1 sigma.v as a function of temperature.
    Uses the function generated by modelParameters.getIsajetData()"""
    
    sig = modelParameters.sigmaFunc(T)
    if not sig or sig < 0.:
        logger.error("Error interpolating sigma.v, sigma = "+str(sig))
        return False
    
    return sig
